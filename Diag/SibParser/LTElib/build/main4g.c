/*
 * Generic converter template for a selected ASN.1 type.
 * Copyright (c) 2005-2017 Lev Walkin <vlm@lionet.info>.
 * All rights reserved.
 *
 * To compile with your own ASN.1 type, redefine the PDU as shown:
 *
 * cc -DPDU=MyCustomType -o myDecoder.o -c converter-example.c
 */
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#define __EXTENSIONS__
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>   /* for atoi(3) */
#include <getopt.h>   /* for getopt(3) */
#include <string.h>   /* for strerror(3) */
#include <sysexits.h> /* for EX_* exit codes */
#include <errno.h>    /* for errno */
#include <unistd.h>   /* for isatty(3) */
#include <asn_application.h>
#include <asn_internal.h> /* for ASN__DEFAULT_STACK_MAX */
#include "LTE.h"
/* Convert "Type" defined by -DPDU into "asn_DEF_Type" */
#ifdef PDU
#define ASN_DEF_PDU(t) asn_DEF_##t
#define DEF_PDU_Type(t) ASN_DEF_PDU(t)
#define PDU_Type DEF_PDU_Type(PDU)
extern asn_TYPE_descriptor_t PDU_Type; /* ASN.1 type to be decoded */
#define PDU_Type_Ptr (&PDU_Type)
#else /* !PDU */
#define PDU_Type_Ptr NULL
#endif /* PDU */

#ifdef ASN_PDU_COLLECTION /* Generated by asn1c -pdu=... */
extern asn_TYPE_descriptor_t *asn_pdu_collection[];
#endif

#ifndef NO_ASN_PDU
#if !defined(PDU) && !defined(ASN_PDU_COLLECTION)
#error Define -DPDU to compile this example converter.
#error `asn1c -pdu=...` adds necessary flags automatically.
#endif
#endif

int parse4G(uint8_t *packet, size_t size,char* pduName)
{
    FILE *binary_out;
    asn_TYPE_descriptor_t *pduType = PDU_Type_Ptr;
    asn_TYPE_descriptor_t *anyPduType = PDU_Type_Ptr;
    ssize_t suggested_bufsize = 8192; /* close or equal to stdio buffer */
    int number_of_iterations = 1;
    int num;
    int ch;
    enum asn_transfer_syntax isyntax = ATS_UNALIGNED_BASIC_PER;
    enum asn_transfer_syntax osyntax = ATS_NONSTANDARD_PLAINTEXT;

    void *structure = 0; /* Decoded structure */
    setvbuf(stdout, 0, _IOLBF, 0);

    uint8_t *i_bptr = packet;
    size_t i_size = size;
    printf("start decode,size %ld, pduname %s\n", i_size, pduName);
    asn_dec_rval_t rval;
    for(int i=0;;i++){
        pduType = asn_pdu_collection[i];
        if (pduType == 0){
            printf("not found %s\n",pduName);
            return 1;
        }
        if (strcmp(pduType->name, pduName) == 0){
            break;
        }
        //printf("pduType->name %s where segfault\n",pduType->name);
    }
    // for (int i_pduType = 0; rval.code != RC_OK; i_pduType++)
    // {
    //     structure = 0;
    //     switch (i_pduType)
    //     {
    //     case 0:
    //         pduType = asn_pdu_collection[4];
    //         break;
    //     case 1:
    //         pduType = asn_pdu_collection[12];
    //         break;
    //     case 2:
    //         pduType = asn_pdu_collection[14];
    //         break;
    //     case 3:
    //         pduType = asn_pdu_collection[16];
    //         break;
    //     case 4:
    //         pduType = asn_pdu_collection[18];
    //         break;
    //     case 5:
    //         pduType = asn_pdu_collection[20];
    //         break;
    //     default:
    //         ASN_STRUCT_FREE(*pduType, structure);
    //         return 1;
    //         break;
    //     }

    //     rval = asn_decode(0, isyntax, pduType, (void **)&structure,
    //                       i_bptr, i_size);
    //     if (rval.code != RC_OK)
    //     {
    //         ASN_STRUCT_FREE(*pduType, structure);
    //     }

    // } // выдели типы pdu и напиши if else для asn_pdu_collection по индексам
    printf("info pduType: %s\n   ", pduType->name);
    rval = asn_decode(0, isyntax, pduType, (void **)&structure,
                          i_bptr, i_size);
    setvbuf(stdout, 0, _IOLBF, 0);

    switch (rval.code)
    {
    case RC_OK:
        asn_fprint(stdout, pduType, structure);
        printf("RC_OK\n");
        break;
    case RC_WMORE:
        printf("RC_WMORE\n");
        break;
    case RC_FAIL:
        printf("RC_FAIL\n");
        break;
    default:
        break;
    }
    ASN_STRUCT_FREE(*pduType, structure);
    printf("end decode\n");
    return 0;
}
